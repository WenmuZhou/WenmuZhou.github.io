<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pytorch学习之路-01-mnist]]></title>
    <url>%2F2018%2F05%2F09%2Fpytorch%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-01-mnist%2F</url>
    <content type="text"><![CDATA[说明本文使用pytorch从mnsit原始图像开始学习并完成输入图像的预测 数据集介绍mnsit是一个广泛使用的手写数字数据集，其包含60000张训练数据集，10000张测试数据集。数据集长这样。 但是从网上下载的数据集一般不是jpg或png格式的,下载的数据长这样。 如何将数据集转换成jpg或者png文件，请参考这篇博客 mnist数据集转换 自定义dataset这里使用自定义的dataset来完成对mnsit数据集的加载,在pytorch中自定义dataset需要继承自torch.utils.data.Dataset，并且要实现__init__,__getitem__和__len__方法。 1234567891011121314151617181920212223242526272829303132333435363738class MyDataset(torch.utils.data.Dataset): def __init__(self, txt, data_shape,channel=3, transform=None, target_transform=None): ''' :param txt: :param data_shape: :param channel: :param transform: :param target_transform: ''' fh = open(txt, 'r') data = [] for line in fh: line = line.strip('\n') line = line.rstrip() words = line.split() data.append((words[0], int(words[1]))) self.data = data self.transform = transform self.target_transform = target_transform self.data_shape = data_shape self.channel = channel def __getitem__(self, index): img_path, label = self.data[index] if self.channel == 3: img = cv2.imread(img_path,1) else: img = cv2.imread(img_path, 0) img = cv2.resize(img, (self.data_shape[0], self.data_shape[1])) img = np.reshape(img,(self.data_shape[0], self.data_shape[1],self.channel)) if self.transform is not None: img = self.transform(img) return img, label def __len__(self): return len(self.data) 网络这里使用torchvision里自带的alexnet 训练12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import torchimport torchvisionimport torch.utils.data as Datafrom torchvision import transformsfrom data_loader import MyDatasetimport timefrom tensorboardX import SummaryWriterdevice = torch.device("cuda:0")print('training with:', device)num_epochs = 3batch_size = 64train_data = MyDataset(txt='/data/datasets/mnist/train.txt', data_shape=(227, 227), channel=3, transform=transforms.ToTensor())train_loader = Data.DataLoader( dataset=train_data, batch_size=batch_size, shuffle=True, num_workers=3)model = torchvision.models.AlexNet(num_classes=10)# 准备写tensorboard, 必须放在'.to(device)'之前，不然会报错writer = SummaryWriter()dummy_input = torch.autograd.Variable(torch.rand(1, 3, 227, 227))writer.add_graph(model=model, input_to_model=(dummy_input, ))model = model.to(device)criterion = torch.nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.001)scheduler = torch.optim.lr_scheduler.StepLR(optimizer, 5, gamma=0.1)model.train()for epoch in range(num_epochs): scheduler.step() train_acc, train_loss = 0., 0. start = time.time() for i, (images, labels) in enumerate(train_loader): images, labels = images.to(device), labels.to(device) # Forward optimizer.zero_grad() out = model(images) # Backward loss = criterion(out, labels) loss.backward() optimizer.step() train_loss += loss.item() _, preds = torch.max(out.data, 1) correct = preds.eq(labels.data).sum().item() acc = correct / labels.size(0) train_acc += correct cur_step = epoch * (train_data.__len__()/batch_size)+i writer.add_scalar(tag='Train/loss', scalar_value=loss.item(), global_step=cur_step) writer.add_scalar(tag='Train/acc', scalar_value=acc, global_step=cur_step) # if i % 1 == 0: # print('Iteration: &#123;&#125;. Loss: &#123;&#125;. Accuracy: &#123;&#125;'.format(cur_step, loss.item(), acc)) print('epoch [%d/%d], loss: %.4f, acc: %.4f, time:%0.4f, lr:%s' % ( epoch + 1, num_epochs, train_loss / len(train_data), train_acc / len(train_loader.dataset), time.time() - start, str(scheduler.get_lr()[0])))writer.close()torch.save(model, 'AlexNet1.pkl') 在训练时有一些超参数设置如下12epoch = 3 # 数据集学习多少次batch_size = 64 # 每次计算多少张图像 为了可视化训练结果，使用了tensorboardX包,这个包将tensorflow的tensorboard功能弄到了pytorch里面。需要注意的是，可视化网络要在model.to(device)之后使用，不然会报错。 在终端中使用下面的命令来启动训练1python train.py 训练结果如下 可视化结果 loss acc 网络结构图 预测拿到模型之后，我们来预测一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import torchimport torch.nn.functional as Ffrom torch.autograd import Variablefrom torchvision import transformsimport timeimport cv2import osimport numpy as npimport argparseclass Pytorch_model: def __init__(self, model_path, img_shape, img_channel=3, gpu_id=None, classes_txt=None): self.gpu_id = gpu_id self.img_shape = img_shape self.img_channel = img_channel if self.gpu_id is not None and isinstance(self.gpu_id, int) and torch.cuda.is_available(): self.device = torch.device("cuda:%s" %(self.gpu_id)) else: self.device = torch.device("cpu") print(self.device) if self.gpu_id is not None and isinstance(self.gpu_id, int): self.use_gpu = True else: self.use_gpu = False if not self.use_gpu: self.net = torch.load(model_path, map_location=lambda storage, loc: storage.cpu()) else: self.net = torch.load(model_path, map_location=lambda storage, loc: storage.cuda(gpu_id)) self.net.eval() if classes_txt is not None: with open(classes_txt, 'r') as f: self.idx2label = dict(line.strip().split(' ') for line in f if line) else: self.idx2label = None def predict(self, img, is_numpy=False, topk=1): if len(self.img_shape) not in [2, 3] or self.img_channel not in [1, 3]: raise NotImplementedError if not is_numpy and self.img_channel in [1, 3]: # read image if os.path.exists(img): img = cv2.imread(img, 0 if self.img_channel == 1 else 1) else: return 'file is not exists' img = cv2.resize(img, (self.img_shape[0], self.img_shape[1])) if len(img.shape) == 2 and self.img_channel == 3: img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) elif len(img.shape) == 3 and self.img_channel == 1: img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) img = img.reshape([self.img_shape[0], self.img_shape[1], self.img_channel]) tensor = transforms.ToTensor()(img) tensor = tensor.unsqueeze_(0) tensor = Variable(tensor) tensor = tensor.to(self.device) outputs = F.softmax(self.net(tensor),dim=1) result = torch.topk(outputs.data[0], k=topk) if self.device != "cpu": index = result[1].cpu().numpy().tolist() prob = result[0].cpu().numpy().tolist() else: index = result[1].numpy().tolist() prob = result[0].numpy().tolist() if self.idx2label is not None: label = [] for idx in index: label.append(self.idx2label[str(idx)]) result = label, prob else: result = index, prob return resultif __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('-f','--file', type=str, help='test image file') parser.add_argument('-m','--model', type=str, help='model used') args = parser.parse_args() img_path = args.file model_path = args.model img_shape = [227,227] img_channel = 3 # test cpu speed model = Pytorch_model(model_path, img_shape=img_shape,img_channel=img_channel, classes_txt='labels.txt') start_cpu = time.time() epoch = 1 for _ in range(epoch): start = time.time() result = model.predict(img_path,topk=3) print('device: cpu, result:%s, time: %.4f' % (str(result), time.time() - start)) end_cpu = time.time() # test gpu speed model1 = Pytorch_model(model_path=model_path, img_shape=img_shape,img_channel=img_channel, gpu_id=0, classes_txt='labels.txt') start_gpu = time.time() for _ in range(epoch): start = time.time() result = model1.predict(img_path,topk=3) print('device: gpu, result:%s, time: %.4f' % (str(result), time.time() - start)) end_gpu = time.time() print('cpu avg time: %.4f' % ((end_cpu - start_cpu) / epoch)) print('gpu avg time: %.4f' % ((end_gpu - start_gpu) / epoch)) 调用代码1python predict.py -f /data/datasets/mnist/test/0/0_1.png -m AlexNet.pkl 使用的预测图像为 预测结果如下，脚本输出了top3分别为 类别 置信度 0 0.999999 9 0.000002 6 0.000002]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
        <tag>mnist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git操作]]></title>
    <url>%2F2018%2F04%2F12%2Fgit%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[拉取远程分支step1:查看所有远程分支1git branch -r step2:拉取远程分支并创建本地分支方法一使用如下命令：1git checkout -b 本地分支名x origin/远程分支名x 使用该方式会在本地新建分支x，并自动切换到该本地分支x。 采用此种方法建立的本地分支会和远程分支建立映射关系。 方式二使用如下命令：1git fetch origin 远程分支名x:本地分支名x 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。 采用此种方法建立的本地分支不会和远程分支建立映射关系。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2018%2F04%2F12%2FLinux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[登录服务器登录服务器并设置可显示服务器软件GUI1ssh -X zj@ip 压缩及解压7z压缩17za a -t7z -r Mytest.7z /opt/phpMyAdmin-3.3.8.1-all-languages/* 参数含义：a 代表添加文件／文件夹到压缩包-t 是指定压缩类型，这里定为7z，可不指定，因为7za默认压缩类型就是7z。-r 表示递归所有的子文件夹Mytest.7z 是压缩好后的压缩包名/opt/phpMyAdmin-3.3.8.1-all-languages/*：是目录压缩目标。 解压17za x xxx.7z -r -o./ zip压缩将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件,－r表示递归压缩子目录下所有文件.1zip -r myfile.zip ./* 解压1zip -r filename.zip filesdir 在这个例子里，filename.zip 代表你创建的文件，filesdir 代表你想放置新 zip 文件的目录。-r 选项指定你想递归地（recursively）包括所有包括在 filesdir 目录中的文件。 要抽取 zip 文件的内容，键入以下命令：1unzip filename.zip 你可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：1zip -r filename.zip file1 file2 file3 /usr/work/school 上面的命令把 file1、file2、 file3、以及 /usr/work/school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解锁Docker技能，再也不用担心环境和小伙伴冲突了]]></title>
    <url>%2F2017%2F12%2F27%2F%E8%A7%A3%E9%94%81Docker%E6%8A%80%E8%83%BD%EF%BC%8C%E5%86%8D%E4%B9%9F%E4%B8%8D%E7%94%A8%E6%8B%85%E5%BF%83%E7%8E%AF%E5%A2%83%E5%92%8C%E5%B0%8F%E4%BC%99%E4%BC%B4%E5%86%B2%E7%AA%81%E4%BA%86%2F</url>
    <content type="text"><![CDATA[以基于ubuntu镜像创建自己的镜像并打包带走为例解读docker的使用方法。ps:docker命令和git命令极其相似 step1 查找ubuntu镜像在安装好docker之后，我们需要使用如下命令来查找需要的镜像1docker search 镜像关键字 step2 下载ubuntu镜像查找完成之后，使用如下命令来下载需要的镜像1docker pull 镜像仓库全称 step3 启动ubuntu镜像下载完成之后，使用如下命令来下载启动的镜像1nvidia-docker run --name zj-ubuntu -i -t ubuntu 其中，--name表示使用基于ubuntu镜像创建一个名称为zj-ubuntu的临时镜像，-i 以交互模式运行容器，-t 为容器重新分配一个伪输入终端，加上-i -t之后，当前终端会被镜像里的终端代替 此时通过下面的命令可以查询当前运行的镜像信息1docker ps -a 启动时，挂载本地文件夹1nvidia-docker run --name zj-ubuntu -i -t -v /data:/data ubuntu -v表示挂载本地文件夹，后面的/data:/data，前一个/data表示宿主机文件夹，后一个/data表示镜像里显示的文件夹。 至此，已经完成了镜像的下载和运行，但是在运行镜像之后搭好的环境怎么保存呢？ step4 退出容器通过run命令开始的镜像，会形成一个容器，这是可以理解为，我们的机器开机了，想关机，直接输入exit就能够完成关机，此时使用下面命令可以获得容器id1docker ps -a 获得容器id之后，可以使用下面的命令开机并再次进入。12docker start 容器id或容器名 #开机docker attach 容器id或容器名 #登录 step5 保存ubuntu镜像在对镜像做完更改之后，使用如下命令来保存更改1docker commit -a "zj" -m "456" 93934b35e497 zj-ubuntu1:1.0 -a表示作者信息，-m表示此次更改的提交信息，93934b35e497为镜像id，zj-ubuntu1是镜像保存的仓库名，1.0是镜像的tag信息，可以理解为版本号。 step6 提交zj-ubuntu镜像之前我们已经保存了我们对于ubuntu镜像的更改，并以此创建了一个新的镜像zj-ubuntu1(docker不会再原有的镜像上做更，每次commit都会创建一个新的)。 接下来，我们将创建好的镜像提交到https://hub.docker.com上，已完成打包带走的初衷。 使用如下命令可以提交指定的docker镜像到https://hub.docker.com1docker push 镜像仓库地址 在提交之前，我们需要使用如下命令登录1docker login 随后使用如下命令提交镜像1docker push zj-ubuntu1:1.0 就这么提交会报错可以看到，提交被拒绝了，为什么呢？其实是因为，docker在提交时找不到zj-ubuntu这个用户，我们需要使用下面的命令来对镜像仓库进行修改1docker tag zj-ubuntu1:1.0 wenmu/zj-ubuntu:1.0 wenmu是我的docker用户名。修改完成之后，使用下面的命令就可以愉快的提交了。1docker push wenmu/zj-ubuntu 去官网检查一下 可以看到，提交成功，至此，打包带走完成。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keras or tensorflow 显存占用问题]]></title>
    <url>%2F2017%2F08%2F11%2Fkeras%20or%20tensorflow%20%E6%98%BE%E5%AD%98%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[事件起因实验室服务器上是四块GTX1080ti,但是在运行tensorflow或keras程序时，发现四块卡的显存全部被占用了。就是下面这种情况: 正常应该是这样的 这让我很费解啊。 原因分析出现这种情况的原因是，tensorflow初始化时会默认占满全部显卡和全部剩余显存，这种情况肯定是不行的，你一个人用了全部的，其他人还用不用了？对于这种情况tensorflow官网给出的说法是 By default, TensorFlow maps nearly all of the GPU memory of all GPUs (subject to CUDA_VISIBLE_DEVICES ) visible to the process. This is done to more efficiently use the relatively precious GPU memory resources on the devices by reducing memory fragmentation). 说白了就是，我们为了防止碎片化和为了更好的利用内存，默认占用全部显存。 但是我们不想用这么多也是有办法的 解决办法tensorflow 使用tensorflow时可以使用如下代码来选着使用某块显卡 123 # Creates a graph.with tf.device('/gpu:0'): # write your code here 限制显存使用，官网同样提供了两种解决方案 a.123456789101112config = tf.ConfigProto()config.gpu_options.allow_growth = Truesession = tf.Session(config=config, ...)~~~ 在这种方案下，显存占用会随着epoch的增长而增长，也就是运行后面的eopch时，会去申请新的显存，前面已经完成的epoch所占用的显存并不会释放，原因也是为了防止碎片化。b. ~~~pythonconfig = tf.ConfigProto()config.gpu_options.per_process_gpu_memory_fraction = 0.3session = tf.Session(config=config, ...) 这种方法就比较给力了，告诉tensorflow，我这块显卡只给你30%的显存，其余的你给我放着不动。 keras由于keras是使用的tensorflow后端，所以需要加上额外的语句。123456import osos.environ["CUDA_VISIBLE_DEVICES"] = "1"from keras.backend.tensorflow_backend import set_sessionconfig = tf.ConfigProto()config.gpu_options.per_process_gpu_memory_fraction = 0.3set_session(tf.Session(config=config)) # 此处不同 上面的语句中设定使用那一块显卡和tensorflow有些不同(我没试验过keras是不是可以用tensorflow指定gpu的语句)，需要使用CUDA_VISIBLE_DEVICES这个值来设定，这个值就是让某几块(使用’,’分隔)显卡可以被cuda看见，那么程序也就只能调用那几块显卡了。 需要注意的是，虽然代码或配置层面设置了对显存占用百分比阈值，但在实际运行中如果达到了这个阈值，程序有需要的话还是会突破这个阈值。换而言之如果跑在一个大数据集上还是会用到更多的显存。以上的显存限制仅仅为了在跑小数据集时避免对显存的浪费而已。 下面是只设置1,2卡可见的情况1os.environ["CUDA_VISIBLE_DEVICES"] = "1,2" 下面是正常状态]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>keras</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04 + cuda8.0 + cudnn6.0 + opencv3.2安装caffe]]></title>
    <url>%2F2017%2F06%2F02%2Fubuntu16.04%20%2B%20cuda8.0%20%2B%20cudnn6.0%20%2B%20opencv3.2%E5%AE%89%E8%A3%85caffe%2F</url>
    <content type="text"><![CDATA[step1 安装NVIDIA显卡驱动因为我是重装了系统所以之前没有安过nvidia驱动，如果之前有装得话，可以自行删除，先 通过快捷键Ctrl+Alt+T打开终端1sudo apt-get remove --purge nvidia-* 下面开始安装 首先添加官方源1sudo add-apt-repository ppa:graphics-drivers/ppa 然后刷新软件库并安装(首先先去NVIDIA官网查询自己适合的驱动)12sudo apt-get updatesudo apt-get install nvidia-375 nvidia-settings nvidia-prime 上面的nvidia-375根据你查询的结果自行更改Ps:这方法适用于Ubuntu16.04其他版本可能有问题 安装完成之后重启电脑 然后在命令行输入1nvidia-smi 出现显卡信息说明安装成功 step2 安裝CUDA8.0先下载cuda8.0然后cd进下载目录执行1sudo sh cuda_8.0.61_375.26_linux.run --override 看到这么一步时，选择n12Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 *?(y)es/(n)o/(q)uit: n step3 修改~/.bashrc1sudo gedit ~/.bashrc 在最后加入12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH step4 安裝cuDNN 6.0先下载cuDNN 6.0然后执行1234sudo tar xvf cudnn-8.0-linux-x64-v6.0.tgzsudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* step5 安装依赖及opencv 3.2.012345678910sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential cmake git pkg-config libprotobuf-dev libleveldb-dev libsnappy-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev libgflags-dev libgoogle-glog-dev liblmdb-dev python-pip python-dev python-numpy python-scipysudo apt-get install --no-install-recommends libboost-all-devpip install --upgrade pipsudo pip install Cythoncd ~/wget https://raw.githubusercontent.com/milq/milq/master/scripts/bash/install-opencv.shbash install-opencv.sh#这一步我执行了两次才成功 step6 安装Caffe下载caffe并进入目录12git clone https://github.com/BVLC/caffe.gitcd caffe 复制配置文件1cp Makefile.config.example Makefile.config 修改配置文件1sudo gedit Makefile.config #打开Makefile.config文件 根据个人情况修改文件： a.若使用cudnn，则将1#USE_CUDNN := 1 修改成：1USE_CUDNN := 1 b.若使用的opencv版本是3的，则将1#OPENCV_VERSION := 3 修改为：1OPENCV_VERSION := 3 c.若要使用python来编写layer，则将1#WITH_PYTHON_LAYER := 1 修改为1WITH_PYTHON_LAYER := 1 d.重要的一项 :将1# Whatever else you find you need goes here. 下面的 12INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/includeLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib 修改为：12INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial 这是因为ubuntu16.04的文件包含位置发生了变化，尤其是需要用到的hdf5的位置，所以需要更改这一路径. step7 编译caffe1234make allmake pycaffemake testmake runtest 在任意位置import caffe123sudo gedit ~/.bashrc export PYTHONPATH=~/caffe/python:$PYTHONPATH #上述语句中 “～” 号表示caffe 所在的根目录。 关闭文件，在终端输入下面命令，使环境变量生效1source ~/.bashrc 编译python3版本移除下面语句前面的注释1234# Uncomment to use Python 3 (default is Python 2)PYTHON_LIBRARIES := boost_python3 python3.5mPYTHON_INCLUDE := /usr/include/python3.5m \ /usr/lib/python3.5/dist-packages/numpy/core/include 可能会遇到如下问题1234567CXX .build_release/src/caffe/proto/caffe.pb.ccPROTOC (python) src/caffe/proto/caffe.protoLD -o .build_release/lib/libcaffe.so.1.0.0-rc3CXX/LD -o python/caffe/_caffe.so python/caffe/_caffe.cpp/usr/bin/ld: cannot find -lboost_python3collect2: error: ld returned 1 exit statusmake: *** [python/caffe/_caffe.so] 错误 1 这时候，检查是否有如下文件： !!! 这里的py35根据你的python版本来，我的是python3.5，这里就是py351ls /usr/lib/x86_64-linux-gnu/libboost_python-py35.so 如果有，说明我们的系统中已经有了这种库文件，只是文件名不同。接下来执行下面语句12cd /usr/lib/x86_64-linux-gnu/sudo ln -s libboost_python-py35.so libboost_python3.so 重新编译即可。finish referencehttp://blog.csdn.net/Tang_DH/article/details/52556636http://bleuren.me/106/install-caffe/]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>caffe</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东2017实习生笔试题-终结者C]]></title>
    <url>%2F2017%2F04%2F08%2F%E4%BA%AC%E4%B8%9C2017%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BB%88%E7%BB%93%E8%80%85C%2F</url>
    <content type="text"><![CDATA[题目 收到情报，有批新造的机器人要运输到前线。小C将去破坏机器人的运输。小C将激光炮放置在公路的一旁，等运输车经过的时候发射（假设激光炮一定可以射穿车辆）。由于能源有限，激光炮只能发射两次。可以认为激光炮放在坐标轴的原点处，并向y轴正方向发射。每辆运输车可以看作是一个矩形，起始的x轴坐标为Xi ,所有的车均位于第一象限，长度为Li,速度为1，朝x轴负方向运动。即经过t时间后，该车车头的x坐标为Xi-t，车尾坐标为Xi-t+Li 。只要打中车的任何一个部分就算击中。请你算算，他在哪两个时刻发射，才能摧毁最多的运输车。 输入描述 第一行一个正整数 n ( 2≤N≤200 )，表示运输个的数量。接下来n行，每行两个整数X和L(1≤X、L≤109)，表示一辆车的x轴坐标和长度。 输出描述 输出最多可以摧毁的运输车数量。 输入例子 42 23 15 2 输出例子 4 问题分析这题基本思想是移动炮台去打车，跟随者一次次提交来理解正确答案的思想吧 第一次提交想法先确定车辆的区间范围，然后在那个区间里面找出第一次开炮能够打到的最大车辆数，将这些车辆从车辆列表里一处，然后再找出一次开炮能够打到的最大车辆数，两次相加即为最大摧毁数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int max_val;int getMax(vector&lt;int&gt; x_vec, vector&lt;int&gt; l_vec, vector&lt;bool&gt; visit_vec, int n) &#123; int max = x_vec[0]+l_vec[0], min = x_vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (x_vec[i] + l_vec[i] &gt;= max) &#123; max = x_vec[i] + l_vec[i]; &#125; if (x_vec[i] &lt;= min) &#123; min = x_vec[i]; &#125; &#125; int lena = max - min + 1; int a[lena]; for (int i = 0; i &lt; lena; i++) &#123; a[i] = 0; for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; i + min &gt;= x_vec[j] &amp;&amp; i + min &lt;= x_vec[j] + l_vec[j]) &#123; a[i]++; &#125; &#125; &#125; int max_value = 0; int max_index = 0; for (int k = 0; k &lt; lena; k++) &#123; if (a[k] &gt;= max_value) &#123; max_value = a[k]; max_index = k; &#125; &#125; max_val = max_value; return max_index + min;&#125;void func(vector&lt;int&gt; x_vec, vector&lt;int&gt; l_vec, int n) &#123; vector&lt;bool&gt; visit_vec; for (int j = 0; j &lt; n; ++j) &#123; visit_vec.push_back(false); &#125; int max_index = getMax(x_vec, l_vec, visit_vec, n); int sum = max_val; for (int j = 0; j &lt; n; j++) &#123; if (max_index &gt;= x_vec[j] &amp;&amp; max_index &lt;= x_vec[j] + l_vec[j]) &#123; visit_vec[j] = true; &#125; &#125; getMax(x_vec, l_vec, visit_vec, n); cout &lt;&lt; max_val + sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; x_vec; vector&lt;int&gt; l_vec; int n, x, speed; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; speed; x_vec.push_back(x); l_vec.push_back(speed); &#125; func(x_vec, l_vec, n); return 0;&#125; 结果 结果分析可以看到只能通过89%，咋一看思路很有问题，但是求得的是一个局部最优，并不能代表全局最优，所有下面这种情况会通不过。 这种情况下，我们的算法只能得到5个，但是最优解是6个 第二次提交修改思路 枚举所有的两处射击地点。选择摧毁车辆最大数的两处 修改代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void resetVisit(vector&lt;bool&gt; &amp;visit_vec, int n) &#123; visit_vec.push_back(false); visit_vec.clear(); for (int i = 0; i &lt; n; ++i) &#123; visit_vec.push_back(false); &#125;&#125;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int r = end_vec[0], l = start_vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (end_vec[i] &gt;= r) &#123; r = end_vec[i]; &#125; if (start_vec[i] &lt;= l) &#123; l = start_vec[i]; &#125; &#125; vector&lt;bool&gt; visit_vec; resetVisit(visit_vec, n); int sum = 0; for (int i = l; i &lt;= r; i++) &#123; int count1 = 0; resetVisit(visit_vec, n); for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; i &gt;= start_vec[j] &amp;&amp; i &lt;= end_vec[j]) &#123; visit_vec[j] = true; count1++; &#125; &#125; for (int k = i + 1; k &lt;= r; k++) &#123; vector&lt;int&gt; hais_visit; int count = 0; for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; k &gt;= start_vec[j] &amp;&amp; k &lt;= end_vec[j]) &#123; visit_vec[j] = true; hais_visit.push_back(j); count++; &#125; &#125; for (int m = 0; m &lt; hais_visit.size(); ++m) &#123; visit_vec[hais_visit[m]] = false; &#125; hais_visit.clear();// cout &lt;&lt; "count1:" &lt;&lt; count1 &lt;&lt; " count:" &lt;&lt; count &lt;&lt; endl; if (count + count1 &gt; sum) &#123; sum = count + count1; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; 结果如下 超时了，注意到上面的遍历是按照车辆区间来的，当区间比较大时，时间复杂度会很高，正确思路应该是按照车辆数来遍历 第三次提交注意了正确答案快要接近了代码思想 选取两个车辆作为射击点，当其他车辆的车头在选取的车辆车身区间时，该车辆视为可被摧毁。三次循环解决问题 修改之后代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int count = 0; for (int k = 0; k &lt; n; k++) &#123; if ((start_vec[k] &gt;= start_vec[i] &amp;&amp; start_vec[k] &lt;= end_vec[i]) || (start_vec[k] &gt;= start_vec[j] &amp;&amp; start_vec[k] &lt;= end_vec[j])) &#123; count++; &#125; &#125; if (count &gt; sum) &#123; sum = count; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; 结果 妈卖批，结果又错了分析一下！！！！ 上面这种情况下，代码算出的是4，实际上是3，从图中可以看出很明显的错误 再次修改代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int count = 0; for (int k = 0; k &lt; n; k++) &#123; if ((start_vec[i] &gt;= start_vec[k] &amp;&amp; start_vec[i] &lt;= end_vec[k]) || (start_vec[j] &gt;= start_vec[k] &amp;&amp; start_vec[j] &lt;= end_vec[k])) &#123; count++; &#125; &#125; if (count &gt; sum) &#123; sum = count; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; AC了，哈哈]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVTE-C++笔试题-求最大和子序列]]></title>
    <url>%2F2017%2F03%2F26%2FCVTE-C%2B%2B%E7%AC%94%E8%AF%95%E9%A2%98-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目 输入一个整型数组，数组里有正数也有负数。 数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值。要求时间复杂度为O(n)。 例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;#define NUM 8int main()&#123; int ary[NUM] = &#123; 1, -2, 3, 10, -4, 7, 2, -5 &#125;; int max = 0;//保存最大和 int curSum = 0;//保存当前和 int curStart = 0;//当前和的起始位置 int start = 0;//最大和的起始位置 int end = 0;//最大和的终止位置 for (int i = 0; i&lt;NUM; i++) &#123; if (i == 0) &#123; curSum = max = ary[i]; continue; &#125; if (curSum&lt;0) &#123; curSum = 0;//与负数相加，和会减小，所以抛弃以前的和 curStart = i; &#125; //最大值已经被保存下来，所以请大胆的继续往前加 curSum += ary[i]; //当前和被保存为最大值，记录下它的起始位置和结束位置 if (curSum&gt;max) &#123; max = curSum; start = curStart; end = i; &#125; &#125; cout &lt;&lt; "和最大的子数组为：" &lt;&lt; endl; for (int i = start; i &lt;= end; i++) &#123; cout &lt;&lt; ary[i] &lt;&lt; " "; &#125; cout &lt;&lt; "= " &lt;&lt; max; cin.get(); return 0;&#125; 结果]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图的最短路径-Floyd算法]]></title>
    <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Floyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述 在带有权值的图中，我们需要找到一点到另外一点所经过的边的权值之和最小，这样的一条边就是最短路径。 基本思想 变量：起始点v0,终点vn,中间点vk如果dis[v0][vn] &gt; dis[v0][vk] + dis[vk][vn],那么久将vk作为从点v0到vn的转折点。 分析 Floyd算法的本质是二重循环初始化最短路径矩阵dis，三重循环修正dis，时间复杂度为o(nxnxn)。上一章说Dijkstra算法智能计算出特定起始点到其他点的最短路径，时间复杂度为o(n*n)，要求出所有点之间的最短路径，可以在外面套一个循环，这样时间复杂度为o(nxnxn)，就和Floyd算法一样。但是Floyd算法的实现更为巧妙。 代码123456789101112131415161718192021222324252627282930313233343536void MyGraph::shortestPathFloyd() &#123; int pathMatrix[this-&gt;num][this-&gt;num]; int shortPath[this-&gt;num][this-&gt;num]; //初始化矩阵 for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = 0; j &lt; this-&gt;num; ++j) &#123; shortPath[i][j] = this-&gt;array[i * this-&gt;num + j]; pathMatrix[i][j] = j; &#125; &#125; //算法主体 for (int k = 0; k &lt; this-&gt;num; ++k) &#123; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = 0; j &lt; this-&gt;num; ++j) &#123; if (shortPath[i][k] + shortPath[k][j] &lt; shortPath[i][j]) &#123; shortPath[i][j] = shortPath[i][k] + shortPath[k][j]; pathMatrix[i][j] = pathMatrix[i][k]; &#125; &#125; &#125; &#125; //打印i到j的最短路径值和路径 for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = i + 1; j &lt; this-&gt;num; ++j) &#123; cout &lt;&lt; this-&gt;node_array[i].data &lt;&lt; "--&gt;" &lt;&lt; this-&gt;node_array[j].data &lt;&lt; " value:" &lt;&lt; shortPath[i][j]; int key = pathMatrix[i][j]; cout &lt;&lt; " path:" &lt;&lt; this-&gt;node_array[i].data; while (key != j) &#123; cout&lt;&lt;"--&gt;"&lt;&lt;this-&gt;node_array[key].data; key = pathMatrix[key][j]; &#125; cout&lt;&lt;"--&gt;"&lt;&lt;this-&gt;node_array[j].data&lt;&lt;endl; &#125; &#125; 所用测试图结构 输出结果]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图的最短路径-Dijkstra算法]]></title>
    <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述 在带有权值的图中，我们需要找到一点到另外一点所经过的边的权值之和最小，这样的一条边就是最短路径。 基本思想 从起始点v0出发，找到和v0相连的点，记录下他们之间的距离。选择距离最短的尾节点v1作为下一个起始点，并记录v1最短路径已找到 从v1出发，找到和v1相连的点，记录下他们之间的距离。比较从v0直接到点vk的距离和v0-&gt;v1-&gt;vk的距离，选择较小的一个值记为v0到vk的距离，并记录vk最短路径已找到 重复步骤2，直到所有的点的最短距离均找到 分析 从过程中可以看到Dijkstra算法可以找到起始点到所有点的最短路径，但是如果我只需要起始点到终点Vn的最短距离，是不是可以减低一下时间复杂度呢？事实上，这个问题在“’大话数据结构“中已经有了说明 Dijkstra算法的时间复杂度为o(nxn)，寻找起始点到特定点的最短距离时间复杂度也是o(nxn)。这就好比你吃了七个包子吃饱了，但是你就开始想，我是不是可以找到一个就能吃饱的包子，很简单，把七个包子做成一个大包子就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void MyGraph::shortestPathDijkstra(int node_index) &#123; //用于存储最短路径下标的数组 patharc[w] = 0,表示w的最短顶点为0 int patharc[this-&gt;num]; //用于存储到各点最短路径的权值和 int shortPath[this-&gt;num]; //final[w] = 1 表示求得顶点到w的最短路径，0表示还未求得 int final[this-&gt;num]; //初始化 for (int i = 0; i &lt; this-&gt;num; i++) &#123; //全部顶点初始化为位置最短路径状态 final[i] = 0; //和node_index相连的的顶点加上权值 shortPath[i] = this-&gt;array[node_index * this-&gt;num + i]; //初始化为0 patharc[i] = 0; &#125; shortPath[node_index] = 0; final[node_index] = 1; int k, min; //开始主循环，每次求得node_index到某个顶点的最短路径 for (int j = 1; j &lt; this-&gt;num; ++j) &#123;//剩余未求得的顶点数，因为第一个点(起始点自身)已经确定，所以从1开始 min = this-&gt;max_value; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; //找到与node_index相距最近的点，下标为k if (!final[i] &amp;&amp; shortPath[i] &lt; min) &#123; k = i; //顶点i距node_index更近 min = shortPath[i]; &#125; &#125; //设置顶点k已访问 final[k] = 1; //修正当前最短路径及距离 //如果点node_index通过点k到于k相连的点s比直接到l近，就更新点node_index到l是距离，并设置到l最近的点为k for (int l = 0; l &lt; this-&gt;num; ++l) &#123; if (!final[l] &amp;&amp; (min + this-&gt;array[k * this-&gt;num + l] &lt; shortPath[l])) &#123; shortPath[l] = min + this-&gt;array[k * this-&gt;num + l]; patharc[l] = k; &#125; &#125; &#125; //输出最短路径和值 for (int m = 1; m &lt; this-&gt;num; ++m) &#123; int key = m; do &#123; cout &lt;&lt; this-&gt;node_array[key].data &lt;&lt; "&lt;---"; key = patharc[key]; &#125; while (key != node_index); cout &lt;&lt; this-&gt;node_array[key].data &lt;&lt; " value:" &lt;&lt; shortPath[m] &lt;&lt; endl; &#125;&#125; 所用测试图结构 输出结果]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易游戏雷火盘古实习生招聘笔试真题-赛马]]></title>
    <url>%2F2017%2F03%2F17%2F%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E8%B5%9B%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[题目 在一条无限长的跑道上，有N匹马在不同的位置上出发开始赛马。当开始赛马比赛后，所有的马开始以自己的速度一直匀速前进。每匹马的速度都不一样，且全部是同样的均匀随机分布。在比赛中当某匹马追上了前面的某匹马时，被追上的马就出局。 请问按以上的规则比赛无限长的时间后，赛道上剩余的马匹数量的数学期望是多少 输入描述 每个测试输入包含1个测试用例输入只有一行，一个正整数N1 &lt;= N &lt;= 1000 输出描述 输出一个浮点数，精确到小数点后四位数字，表示剩余马匹数量的数学期望 输入例子 12 输出例子 1.00001.5000 问题分析 条件 赛道无限长！！！ 赛道无限长！！！ 赛道无限长！！！重要的事情先说三遍 马被追上就出局 马匹的速度不同，所以假设为a1&gt;a2&gt;a3……&gt;ana1一定能活，概率为1a2在a1之后才能活，a2有两种情况:a1之前，a1之后。概率为1/2a2在a1，a2之后才能活，a3有三种情况: a1之前，a1，a2之间，a2之后。概率为1/3…ak在a1….ak-1之后才能活。k种情况，概率为1/k…an在a1….an-1之后才能活。n种情况，概率为1/n即总的期望为1 + 1/2 + 1/3 + …. 1/k + …1/n,归纳得f(n) = f(n-1) + 1/n 代码1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; double sum = 0.0; for (int i = 1; i &lt;= n; i++) &#123; sum = sum + 1.0 / i; &#125; printf("%.4lf\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易游戏雷火盘古实习生招聘笔试真题-推箱子]]></title>
    <url>%2F2017%2F03%2F17%2F%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E6%8E%A8%E7%AE%B1%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目 大家一定玩过“推箱子”这个经典的游戏。具体规则就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，请你求出玩家最少需要移动多少步才能够将游戏目标达成。 输入描述 每个测试输入包含1个测试用例第一行输入两个数字N，M表示地图的大小。其中0&lt;N，M&lt;=8。接下来有N行，每行包含M个字符表示该行地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。每个地图必定包含1个玩家、1个箱子、1个目的地。 输出描述 输出一个数字表示玩家最少需要移动多少步才能将游戏目标达成。当无论如何达成不了的时候，输出-1。 输入例子 4 4…...*@…..X..6 6…#..…… #*##....##.#..X….@#… 输出例子 311 问题分析这题是看了网上的解答才知道是BFS问题，自己一开始用的递归没做出来下面的代码来自 http://blog.csdn.net/u010009169/article/details/60892521 [如有侵权，请联系我删除] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using std::vector;using std::queue;using std::cin;using std::cout;/*4 4......*@.....X..*/int st[10][10][10][10];int x, y, bx, by, tx, ty;int m, n;vector&lt;vector&lt;char&gt;&gt; mm;bool valid(int x, int y) &#123; //cout &lt;&lt;m&lt;&lt;" "&lt;&lt;n&lt;&lt;"-"&lt;&lt;endl; if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; mm[x][y] != '#')return true; return false;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; mm = std::vector&lt;std::vector&lt;char&gt;&gt;(m, vector&lt;char&gt;(n)); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) &#123; char t; cin &gt;&gt; t; if (t == 'X') &#123; x = i; y = j; // cout &lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; &#125; if (t == '*') &#123; bx = i; by = j; &#125; if (t == '@') &#123; tx = i; ty = j; &#125; mm[i][j] = t; &#125;// record every state of the //左，右，下，上 vector&lt;vector&lt;int&gt;&gt; next = &#123;&#123;-1, 0&#125;,&#123;1, 0&#125;,&#123;0, 1&#125;,&#123;0, -1&#125;&#125;; queue&lt;vector&lt;int&gt;&gt; que; que.push(&#123;x, y, bx, by&#125;); st[x][y][bx][by] = 1; while (!que.empty()) &#123; vector&lt;int&gt; t = (vector&lt;int&gt; &amp;&amp;) que.front(); que.pop(); x = t[0]; y = t[1]; bx = t[2]; by = t[3]; for (int i = 0; i &lt; next.size(); i++) &#123; int nx = x + next[i][0], ny = y + next[i][1]; int nnx = nx + next[i][0], nny = ny + next[i][1]; if (valid(nx, ny) &amp;&amp; (nx != bx || ny != by) &amp;&amp; st[nx][ny][bx][by] == 0) &#123; st[nx][ny][bx][by] = st[x][y][bx][by] + 1; que.push(&#123;nx, ny, bx, by&#125;); continue; &#125; else if (nx == bx &amp;&amp; ny == by &amp;&amp; valid(nnx, nny) &amp;&amp; st[nx][ny][nnx][nny] == 0) &#123; st[nx][ny][nnx][nny] = st[x][y][bx][by] + 1; if (mm[nnx][nny] == '@') &#123; cout &lt;&lt; st[nx][ny][nnx][nny] - 1; return 0; &#125; que.push(&#123;nx, ny, nnx, nny&#125;); &#125; &#125; &#125; cout &lt;&lt; -1; return 0;&#125; 代码分析st[10][10][10][10]是一个思维数组，用来存放当前点到终点已经走过了多少步，例如1st[x][y][bx][by] = 1; 程序分为两步走： 人还没到箱子处，人走，箱子不动 人到达箱子处，人和箱子一起动 表示点 (x,y) 到点 (bx,by)之前已经走过的步数为1。用队列来存储待搜索的点。最坏的情况是搜索完全部的点后不能到达终点， 所以队列不为空时会一直进行下去。每次分四个方向走，所以是一个四层循环。第一个if条件判断的是是否到达了目的地处，第二个if条件第一次执行是到了箱子处，到达之后，人开始推着箱子前进，所有人和箱子始终是一个方向的，就有了1st[nx][ny][nnx][nny] = st[x][y][bx][by] + 1 接下来人就换着方向推箱子去找终点]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易游戏雷火盘古实习生招聘笔试真题-最大和]]></title>
    <url>%2F2017%2F03%2F17%2F%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 在一个N*N的数组中寻找所有横，竖，左上到右下，右上到左下，四种方向的直线连续D个数字的和里面最大的值 输入描述 每个测试输入包含1个测试用例，第一行包括两个整数 N 和 D :3 &lt;= N &lt;= 1001 &lt;= D &lt;= N接下来有N行，每行N个数字d:0 &lt;= d &lt;= 100 输出描述 输出一个整数，表示找到的和的最大值 输入例子 4 287 98 79 6110 27 95 7020 64 73 2971 65 15 0 输出例子 193 问题分析每个点需要计算八个方向D个数的和，可以用暴力枚举计算，这样会有很多重复计算对于每个点，我只计算，→，↓，↘，↗四个方向的值。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int getMax(int *array, int n, int d) &#123; int max_sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int line_heng = 0, line_shu = 0, you_shang_line = 0, you_xia_line = 0; for (int k = 0; k &lt; d; k++) &#123; if (i + d &lt;= n) &#123; line_shu += array[(i + k) * n + j]; if(j + d &lt;= n) &#123; you_xia_line += array[(i + k) * n + j + k]; &#125; &#125; if (j + d &lt;= n) &#123; line_heng += array[i * n + j + k]; if (i &gt;= d - 1) &#123; you_shang_line += array[(i - k) * n + j + k]; &#125; &#125; &#125; max_sum = max(max_sum, line_shu); max_sum = max(max_sum, line_heng); max_sum = max(max_sum, you_xia_line); max_sum = max(max_sum, you_shang_line); &#125; &#125; return max_sum;&#125;int main() &#123; int n, d, a; cin &gt;&gt; n &gt;&gt; d; int *array = new int[n * n]; for (int i = 0; i &lt; n * n; i++) &#123; cin &gt;&gt; a; array[i] = a; &#125; cout &lt;&lt; getMax(array, n, d) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易游戏雷火盘古实习生招聘笔试真题-字符串编码]]></title>
    <url>%2F2017%2F03%2F17%2F%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[更新看到了网友一个简洁的代码 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; int num=1; for(int i=1;i&lt;=str.length();i++)&#123; if(str[i]==str[i-1]) num++; else&#123; cout&lt;&lt;num&lt;&lt;str[i-1]; num=1; &#125; &#125; return 0;&#125; 题目:输入描述 每个测试输入包含1个测试用例每个测试用例输入只有一行字符串，字符串只包括大写英文字母，长度不超过10000。 输出描述 输出编码后的字符串 输入例子 AAAABCCDAA 输出例子 4A1B2C1D2A 问题分析仔细审题很容易就过了 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdint.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string bianMa(string s) &#123; string out = ""; int count = 0; char curent_char = s[0]; for (int i = 0; i &lt; s.length(); i++) &#123; if (curent_char == s[i]) &#123; count++; if(i==s.length()-1)&#123; string s1 = to_string(count) + s[i]; out += s1; &#125; &#125; else &#123; string s1 = to_string(count) + s[i-1]; out += s1; count = 1; curent_char = s[i]; if (i == s.length() - 1)&#123; s1 = to_string(count) + s[i]; out += s1; &#125; &#125; &#125; return out;&#125;int main() &#123; string a = "AAAAAA"; cout &lt;&lt; bianMa(a) &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图的最短生成树-kruskal算法]]></title>
    <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E7%94%9F%E6%88%90%E6%A0%91-kruskal%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本思想 每次从所有边中选取权值最小的一条边，将首尾节点加入集合T,剩余节点集合为G 从剩余节点组成的所有边中再选择一条权值最小的边，将首尾节点加入集合T,剩余节点集合为G 重复2并且保证已选出的边不构成回路，直到G中没有节点。 和prim的区别kruskal的计算是基于边的，在边比较少的情况下会比较快，边比较多时，prim会更好。 例子为 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void MyGraph::kruskalTree() &#123; //1、将连接矩阵转换为边集合 int n,m; vector&lt;MyEdge&gt; edge_vector = transformMatrixToEdge(); //用于判断便于边是否形成环路，下标为边的起始点，值为边的结束点 int parent[this-&gt;num]; for(int i = 0;i&lt;this-&gt;num;i++)&#123; parent[i] = 0; &#125; for (int j = 0; j &lt; edge_vector.size(); ++j) &#123; n = this-&gt;Find(parent,edge_vector[j].start); m = this-&gt;Find(parent,edge_vector[j].end); if(n!=m)&#123; parent[n] = m; cout&lt;&lt;this-&gt;node_array[edge_vector[j].start].data&lt;&lt;"---&gt;"&lt;&lt;this-&gt;node_array[edge_vector[j].end].data&lt;&lt;" value: "&lt;&lt;edge_vector[j].value&lt;&lt;endl; &#125; &#125;&#125;vector&lt;MyEdge&gt; MyGraph::transformMatrixToEdge() &#123; vector&lt;MyEdge&gt; edges; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = i+1; j &lt; this-&gt;num; ++j) &#123; if(this-&gt;array[i*this-&gt;num+j]!=this-&gt;max_value) &#123; MyEdge edge = MyEdge(i,j,this-&gt;array[i*this-&gt;num+j]); edges.push_back(edge); &#125; &#125; &#125; for (int k = 0; k &lt; edges.size(); ++k) &#123; for (int i = k+1; i &lt; edges.size(); ++i) &#123; if(edges[k].value&gt;edges[i].value)&#123; MyEdge edge = MyEdge(edges[k].start,edges[k].end,edges[k].value); edges[k] = edges[i]; edges[i] = edge; &#125; &#125; &#125; return edges;&#125;int MyGraph::Find(int *parent, int f) &#123; while(parent[f]&gt;0)&#123; f = parent[f]; &#125; return f;&#125; 运行结果]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图的遍历-深度优先搜索(DFS)和广度优先搜索(BFS)]]></title>
    <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(DFS)%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(BFS)%2F</url>
    <content type="text"><![CDATA[两种遍历图的遍历分为深度优先搜索(Depth First Search)和广度优先搜索 深度优先搜索(DFS) 顺着起始节点的一条边一直找下去，知道这条边上的节点全部被找完，然后再开始顺着另一条边寻找。 广度优先搜索(BFS) 选起始节点连接的所有边，然后将这些边的尾节点中没有访问的加入待寻找节点结合T，起始点置为已访问，接着寻找T中每一个点连接的边，并将尾节点加入T，直到T中包含所有的节点并且都已访问。 例子说明深度优先搜索结果为：A B C E F D G H广度优先搜索结果为：A B D C F G H E 可以看出深度优先搜索就是先一条路走到底，再去走另外的路广度优先搜索就是一层一层的访问 上代码深度优先搜索(DFS)123456789101112void MyGraph::depthFirstTraverse(int node_index) &#123; cout &lt;&lt; this-&gt;node_array[node_index].data &lt;&lt; " "; this-&gt;node_array[node_index].is_visited = true; for (int i = 0; i &lt; this-&gt;num; i++) &#123; if (this-&gt;array[node_index * this-&gt;num + i] != 65535) &#123; if (!this-&gt;node_array[i].is_visited) &#123; depthFirstTraverse(i); &#125; &#125; &#125;&#125; 广度优先搜索(BFS)需要使用两个结合来存储上层访问的节点和下一层待访问的节点，然后递归调用 breadthFirstTraverseIndex()123456789101112131415161718192021222324252627282930void MyGraph::breadthFirstTraverse(int node_index) &#123; cout &lt;&lt; this-&gt;node_array[node_index].data &lt;&lt; " "; //已经访问过的节点就不再访问 this-&gt;node_array[node_index].is_visited = true; vector&lt;int&gt; cur; cur.push_back(node_index); this-&gt;breadthFirstTraverseIndex(cur);&#125;void MyGraph::breadthFirstTraverseIndex(vector&lt;int&gt; previous) &#123; if (previous.size() &lt;= 0) &#123; return; &#125; vector&lt;int&gt; last; for (int i = 0; i &lt; previous.size(); i++) &#123; for (int j = 0; j &lt; this-&gt;num; j++) &#123; if (this-&gt;array[previous[i] * this-&gt;num + j] != 65535) &#123; if (!this-&gt;node_array[j].is_visited) &#123; cout &lt;&lt; this-&gt;node_array[j].data &lt;&lt; " "; //已经访问过的节点就不再访问 this-&gt;node_array[j].is_visited = true; last.push_back(j); &#125; &#125; &#125; &#125; this-&gt;breadthFirstTraverseIndex(last);&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之图的最短生成树-prim算法]]></title>
    <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E7%94%9F%E6%88%90%E6%A0%91-prim%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本思想 最小生成树(Minimum cost Spanning Tree)构造连通图的最小代价生成树称为最小生成树—《大话数据结构》通俗来说就是寻找权值最小的路径集合来连接图中所有的节点。 prim算法 将起始点(可以是图中的任意节点)加入集合G. 从图中寻找到G最短的路径，加入路径集合T. 并把路径的终点加入集合G. 重复步骤2，知道G中包含所有的点 or T中边数量=点的数量-1. 为了实现此算法，我们需要定义几个变量 保存剩余节点到G的最短距离的集合lowcost 1int lowcost[num] //下标为外部的点，值为到G的距离 保存lowcost中每个边连接到G中的哪一个节点的节点集合 1int adjvex[num] //下标为外部的点，值为G中的点 代码是在大话数据结构的基础上修改的–现在能从任意节点开始图的初始化为123456789for (int i = 0; i &lt; this-&gt;num; i++) &#123; for (int j = 0; j &lt; this-&gt;num; j++) &#123; if (i == j) &#123; this-&gt;array[i * num + j] = 0; &#125; else &#123; this-&gt;array[i * num + j] = 65535; &#125;; &#125; &#125; 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546void MyGraph::primTree(int node_index) &#123; int min, i, j, k, MAXVELUE = 65535; //保存最短边的起始点，下标为外部的点，值为当前生成树中的点 int adjvex[this-&gt;num]; //保存各顶点到当前最小生成树的距离(权值)，下标为外部的点，值为到当前生成树的距离 int lowcost[this-&gt;num]; //将和起始点相关的点之间的权值加入,并设置起始点为node_index处的点 for (i = 0; i &lt; this-&gt;num; i++) &#123; lowcost[i] = this-&gt;array[node_index * num + i]; adjvex[i] = node_index; &#125; //循环剩下的点 for (i = 0; i &lt; this-&gt;num; i++) &#123; if (i != node_index) &#123; min = MAXVELUE; j = 0; k = 0; /* 循环全部顶点 选择最小值*/ while (j &lt; this-&gt;num) &#123; if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min) &#123; /* 当前权值成为最小值 */ min = lowcost[j]; /* 将当前最小值的下标存入k */ k = j; &#125; j++; &#125; cout &lt;&lt; "bian: (" &lt;&lt; this-&gt;node_array[adjvex[k]].data &lt;&lt; "," &lt;&lt; this-&gt;node_array[k].data &lt;&lt; ")" &lt;&lt; endl; /* 将当前顶点的权值设置为0,表示此顶点已经加入生成树豪华套餐 */ lowcost[k] = 0; //重新计算剩余点到生成树的距离 for (j = 0; j &lt; this-&gt;num; j++) &#123; /* 如果下标为k顶点各边权值小于此前这些顶点到达生成树的最短距离 */ if (lowcost[j] != 0 &amp;&amp; this-&gt;array[k * this-&gt;num + j] &lt; lowcost[j]) &#123; /* 将较小的权值存入lowcost相应位置 */ lowcost[j] = this-&gt;array[k * this-&gt;num + j]; /* 将当前最短边的起始点置为k */ adjvex[j] = k; &#125; &#125; &#125; &#125;&#125; 运行例子中的图为 以节点B开始，最终输出为]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
</search>
