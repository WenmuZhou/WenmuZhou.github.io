<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[京东2017实习生笔试题-终结者C]]></title>
      <url>%2F2017%2F04%2F08%2F%E4%BA%AC%E4%B8%9C2017%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95%E9%A2%98-%E7%BB%88%E7%BB%93%E8%80%85C%2F</url>
      <content type="text"><![CDATA[题目 收到情报，有批新造的机器人要运输到前线。小C将去破坏机器人的运输。小C将激光炮放置在公路的一旁，等运输车经过的时候发射（假设激光炮一定可以射穿车辆）。由于能源有限，激光炮只能发射两次。可以认为激光炮放在坐标轴的原点处，并向y轴正方向发射。每辆运输车可以看作是一个矩形，起始的x轴坐标为Xi ,所有的车均位于第一象限，长度为Li,速度为1，朝x轴负方向运动。即经过t时间后，该车车头的x坐标为Xi-t，车尾坐标为Xi-t+Li 。只要打中车的任何一个部分就算击中。请你算算，他在哪两个时刻发射，才能摧毁最多的运输车。 输入描述 第一行一个正整数 n ( 2≤N≤200 )，表示运输个的数量。接下来n行，每行两个整数X和L(1≤X、L≤109)，表示一辆车的x轴坐标和长度。 输出描述 输出最多可以摧毁的运输车数量。 输入例子 42 23 15 2 输出例子 4 问题分析这题基本思想是移动炮台去打车，跟随者一次次提交来理解正确答案的思想吧 第一次提交想法先确定车辆的区间范围，然后在那个区间里面找出第一次开炮能够打到的最大车辆数，将这些车辆从车辆列表里一处，然后再找出一次开炮能够打到的最大车辆数，两次相加即为最大摧毁数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int max_val;int getMax(vector&lt;int&gt; x_vec, vector&lt;int&gt; l_vec, vector&lt;bool&gt; visit_vec, int n) &#123; int max = x_vec[0]+l_vec[0], min = x_vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (x_vec[i] + l_vec[i] &gt;= max) &#123; max = x_vec[i] + l_vec[i]; &#125; if (x_vec[i] &lt;= min) &#123; min = x_vec[i]; &#125; &#125; int lena = max - min + 1; int a[lena]; for (int i = 0; i &lt; lena; i++) &#123; a[i] = 0; for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; i + min &gt;= x_vec[j] &amp;&amp; i + min &lt;= x_vec[j] + l_vec[j]) &#123; a[i]++; &#125; &#125; &#125; int max_value = 0; int max_index = 0; for (int k = 0; k &lt; lena; k++) &#123; if (a[k] &gt;= max_value) &#123; max_value = a[k]; max_index = k; &#125; &#125; max_val = max_value; return max_index + min;&#125;void func(vector&lt;int&gt; x_vec, vector&lt;int&gt; l_vec, int n) &#123; vector&lt;bool&gt; visit_vec; for (int j = 0; j &lt; n; ++j) &#123; visit_vec.push_back(false); &#125; int max_index = getMax(x_vec, l_vec, visit_vec, n); int sum = max_val; for (int j = 0; j &lt; n; j++) &#123; if (max_index &gt;= x_vec[j] &amp;&amp; max_index &lt;= x_vec[j] + l_vec[j]) &#123; visit_vec[j] = true; &#125; &#125; getMax(x_vec, l_vec, visit_vec, n); cout &lt;&lt; max_val + sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; x_vec; vector&lt;int&gt; l_vec; int n, x, speed; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; speed; x_vec.push_back(x); l_vec.push_back(speed); &#125; func(x_vec, l_vec, n); return 0;&#125; 结果 结果分析可以看到只能通过89%，咋一看思路很有问题，但是求得的是一个局部最优，并不能代表全局最优，所有下面这种情况会通不过。 这种情况下，我们的算法只能得到5个，但是最优解是6个 第二次提交修改思路 枚举所有的两处射击地点。选择摧毁车辆最大数的两处 修改代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void resetVisit(vector&lt;bool&gt; &amp;visit_vec, int n) &#123; visit_vec.push_back(false); visit_vec.clear(); for (int i = 0; i &lt; n; ++i) &#123; visit_vec.push_back(false); &#125;&#125;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int r = end_vec[0], l = start_vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (end_vec[i] &gt;= r) &#123; r = end_vec[i]; &#125; if (start_vec[i] &lt;= l) &#123; l = start_vec[i]; &#125; &#125; vector&lt;bool&gt; visit_vec; resetVisit(visit_vec, n); int sum = 0; for (int i = l; i &lt;= r; i++) &#123; int count1 = 0; resetVisit(visit_vec, n); for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; i &gt;= start_vec[j] &amp;&amp; i &lt;= end_vec[j]) &#123; visit_vec[j] = true; count1++; &#125; &#125; for (int k = i + 1; k &lt;= r; k++) &#123; vector&lt;int&gt; hais_visit; int count = 0; for (int j = 0; j &lt; n; j++) &#123; if (visit_vec[j] != true &amp;&amp; k &gt;= start_vec[j] &amp;&amp; k &lt;= end_vec[j]) &#123; visit_vec[j] = true; hais_visit.push_back(j); count++; &#125; &#125; for (int m = 0; m &lt; hais_visit.size(); ++m) &#123; visit_vec[hais_visit[m]] = false; &#125; hais_visit.clear();// cout &lt;&lt; "count1:" &lt;&lt; count1 &lt;&lt; " count:" &lt;&lt; count &lt;&lt; endl; if (count + count1 &gt; sum) &#123; sum = count + count1; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; 结果如下 超时了，注意到上面的遍历是按照车辆区间来的，当区间比较大时，时间复杂度会很高，正确思路应该是按照车辆数来遍历 第三次提交注意了正确答案快要接近了代码思想 选取两个车辆作为射击点，当其他车辆的车头在选取的车辆车身区间时，该车辆视为可被摧毁。三次循环解决问题 修改之后代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int count = 0; for (int k = 0; k &lt; n; k++) &#123; if ((start_vec[k] &gt;= start_vec[i] &amp;&amp; start_vec[k] &lt;= end_vec[i]) || (start_vec[k] &gt;= start_vec[j] &amp;&amp; start_vec[k] &lt;= end_vec[j])) &#123; count++; &#125; &#125; if (count &gt; sum) &#123; sum = count; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; 结果 妈卖批，结果又错了分析一下！！！！ 上面这种情况下，代码算出的是4，实际上是3，从图中可以看出很明显的错误 再次修改代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void func(vector&lt;int&gt; start_vec, vector&lt;int&gt; end_vec, int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int count = 0; for (int k = 0; k &lt; n; k++) &#123; if ((start_vec[i] &gt;= start_vec[k] &amp;&amp; start_vec[i] &lt;= end_vec[k]) || (start_vec[j] &gt;= start_vec[k] &amp;&amp; start_vec[j] &lt;= end_vec[k])) &#123; count++; &#125; &#125; if (count &gt; sum) &#123; sum = count; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123; vector&lt;int&gt; start_vec; vector&lt;int&gt; end_vec; int n, x, len; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; x &gt;&gt; len; start_vec.push_back(x); end_vec.push_back(x + len); &#125; func(start_vec, end_vec, n); return 0;&#125; AC了，哈哈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017CVTE-C++笔试题-求最大和子序列]]></title>
      <url>%2F2017%2F03%2F26%2F2017CVTE-C%2B%2B%E7%AC%94%E8%AF%95%E9%A2%98-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%92%8C%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
      <content type="text"><![CDATA[题目 输入一个整型数组，数组里有正数也有负数。 数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值。要求时间复杂度为O(n)。 例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2， 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;#define NUM 8int main()&#123; int ary[NUM] = &#123; 1, -2, 3, 10, -4, 7, 2, -5 &#125;; int max = 0;//保存最大和 int curSum = 0;//保存当前和 int curStart = 0;//当前和的起始位置 int start = 0;//最大和的起始位置 int end = 0;//最大和的终止位置 for (int i = 0; i&lt;NUM; i++) &#123; if (i == 0) &#123; curSum = max = ary[i]; continue; &#125; if (curSum&lt;0) &#123; curSum = 0;//与负数相加，和会减小，所以抛弃以前的和 curStart = i; &#125; //最大值已经被保存下来，所以请大胆的继续往前加 curSum += ary[i]; //当前和被保存为最大值，记录下它的起始位置和结束位置 if (curSum&gt;max) &#123; max = curSum; start = curStart; end = i; &#125; &#125; cout &lt;&lt; "和最大的子数组为：" &lt;&lt; endl; for (int i = start; i &lt;= end; i++) &#123; cout &lt;&lt; ary[i] &lt;&lt; " "; &#125; cout &lt;&lt; "= " &lt;&lt; max; cin.get(); return 0;&#125; 结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之图的最短路径-Floyd算法]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Floyd%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[问题描述 在带有权值的图中，我们需要找到一点到另外一点所经过的边的权值之和最小，这样的一条边就是最短路径。 基本思想 变量：起始点v0,终点vn,中间点vk如果dis[v0][vn] &gt; dis[v0][vk] + dis[vk][vn],那么久将vk作为从点v0到vn的转折点。 分析 Floyd算法的本质是二重循环初始化最短路径矩阵dis，三重循环修正dis，时间复杂度为o(nxnxn)。上一章说Dijkstra算法智能计算出特定起始点到其他点的最短路径，时间复杂度为o(n*n)，要求出所有点之间的最短路径，可以在外面套一个循环，这样时间复杂度为o(nxnxn)，就和Floyd算法一样。但是Floyd算法的实现更为巧妙。 代码123456789101112131415161718192021222324252627282930313233343536void MyGraph::shortestPathFloyd() &#123; int pathMatrix[this-&gt;num][this-&gt;num]; int shortPath[this-&gt;num][this-&gt;num]; //初始化矩阵 for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = 0; j &lt; this-&gt;num; ++j) &#123; shortPath[i][j] = this-&gt;array[i * this-&gt;num + j]; pathMatrix[i][j] = j; &#125; &#125; //算法主体 for (int k = 0; k &lt; this-&gt;num; ++k) &#123; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = 0; j &lt; this-&gt;num; ++j) &#123; if (shortPath[i][k] + shortPath[k][j] &lt; shortPath[i][j]) &#123; shortPath[i][j] = shortPath[i][k] + shortPath[k][j]; pathMatrix[i][j] = pathMatrix[i][k]; &#125; &#125; &#125; &#125; //打印i到j的最短路径值和路径 for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = i + 1; j &lt; this-&gt;num; ++j) &#123; cout &lt;&lt; this-&gt;node_array[i].data &lt;&lt; "--&gt;" &lt;&lt; this-&gt;node_array[j].data &lt;&lt; " value:" &lt;&lt; shortPath[i][j]; int key = pathMatrix[i][j]; cout &lt;&lt; " path:" &lt;&lt; this-&gt;node_array[i].data; while (key != j) &#123; cout&lt;&lt;"--&gt;"&lt;&lt;this-&gt;node_array[key].data; key = pathMatrix[key][j]; &#125; cout&lt;&lt;"--&gt;"&lt;&lt;this-&gt;node_array[j].data&lt;&lt;endl; &#125; &#125; 所用测试图结构 输出结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之图的最短路径-Dijkstra算法]]></title>
      <url>%2F2017%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[问题描述 在带有权值的图中，我们需要找到一点到另外一点所经过的边的权值之和最小，这样的一条边就是最短路径。 基本思想 从起始点v0出发，找到和v0相连的点，记录下他们之间的距离。选择距离最短的尾节点v1作为下一个起始点，并记录v1最短路径已找到 从v1出发，找到和v1相连的点，记录下他们之间的距离。比较从v0直接到点vk的距离和v0-&gt;v1-&gt;vk的距离，选择较小的一个值记为v0到vk的距离，并记录vk最短路径已找到 重复步骤2，直到所有的点的最短距离均找到 分析 从过程中可以看到Dijkstra算法可以找到起始点到所有点的最短路径，但是如果我只需要起始点到终点Vn的最短距离，是不是可以减低一下时间复杂度呢？事实上，这个问题在“’大话数据结构“中已经有了说明 Dijkstra算法的时间复杂度为o(nxn)，寻找起始点到特定点的最短距离时间复杂度也是o(nxn)。这就好比你吃了七个包子吃饱了，但是你就开始想，我是不是可以找到一个就能吃饱的包子，很简单，把七个包子做成一个大包子就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void MyGraph::shortestPathDijkstra(int node_index) &#123; //用于存储最短路径下标的数组 patharc[w] = 0,表示w的最短顶点为0 int patharc[this-&gt;num]; //用于存储到各点最短路径的权值和 int shortPath[this-&gt;num]; //final[w] = 1 表示求得顶点到w的最短路径，0表示还未求得 int final[this-&gt;num]; //初始化 for (int i = 0; i &lt; this-&gt;num; i++) &#123; //全部顶点初始化为位置最短路径状态 final[i] = 0; //和node_index相连的的顶点加上权值 shortPath[i] = this-&gt;array[node_index * this-&gt;num + i]; //初始化为0 patharc[i] = 0; &#125; shortPath[node_index] = 0; final[node_index] = 1; int k, min; //开始主循环，每次求得node_index到某个顶点的最短路径 for (int j = 1; j &lt; this-&gt;num; ++j) &#123;//剩余未求得的顶点数，因为第一个点(起始点自身)已经确定，所以从1开始 min = this-&gt;max_value; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; //找到与node_index相距最近的点，下标为k if (!final[i] &amp;&amp; shortPath[i] &lt; min) &#123; k = i; //顶点i距node_index更近 min = shortPath[i]; &#125; &#125; //设置顶点k已访问 final[k] = 1; //修正当前最短路径及距离 //如果点node_index通过点k到于k相连的点s比直接到l近，就更新点node_index到l是距离，并设置到l最近的点为k for (int l = 0; l &lt; this-&gt;num; ++l) &#123; if (!final[l] &amp;&amp; (min + this-&gt;array[k * this-&gt;num + l] &lt; shortPath[l])) &#123; shortPath[l] = min + this-&gt;array[k * this-&gt;num + l]; patharc[l] = k; &#125; &#125; &#125; //输出最短路径和值 for (int m = 1; m &lt; this-&gt;num; ++m) &#123; int key = m; do &#123; cout &lt;&lt; this-&gt;node_array[key].data &lt;&lt; "&lt;---"; key = patharc[key]; &#125; while (key != node_index); cout &lt;&lt; this-&gt;node_array[key].data &lt;&lt; " value:" &lt;&lt; shortPath[m] &lt;&lt; endl; &#125;&#125; 所用测试图结构 输出结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017网易游戏雷火盘古实习生招聘笔试真题-赛马]]></title>
      <url>%2F2017%2F03%2F17%2F2017%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E8%B5%9B%E9%A9%AC%2F</url>
      <content type="text"><![CDATA[题目 在一条无限长的跑道上，有N匹马在不同的位置上出发开始赛马。当开始赛马比赛后，所有的马开始以自己的速度一直匀速前进。每匹马的速度都不一样，且全部是同样的均匀随机分布。在比赛中当某匹马追上了前面的某匹马时，被追上的马就出局。 请问按以上的规则比赛无限长的时间后，赛道上剩余的马匹数量的数学期望是多少 输入描述 每个测试输入包含1个测试用例输入只有一行，一个正整数N1 &lt;= N &lt;= 1000 输出描述 输出一个浮点数，精确到小数点后四位数字，表示剩余马匹数量的数学期望 输入例子 12 输出例子 1.00001.5000 问题分析 条件 赛道无限长！！！ 赛道无限长！！！ 赛道无限长！！！重要的事情先说三遍 马被追上就出局 马匹的速度不同，所以假设为a1&gt;a2&gt;a3……&gt;ana1一定能活，概率为1a2在a1之后才能活，a2有两种情况:a1之前，a1之后。概率为1/2a2在a1，a2之后才能活，a3有三种情况: a1之前，a1，a2之间，a2之后。概率为1/3…ak在a1….ak-1之后才能活。k种情况，概率为1/k…an在a1….an-1之后才能活。n种情况，概率为1/n即总的期望为1 + 1/2 + 1/3 + …. 1/k + …1/n,归纳得f(n) = f(n-1) + 1/n 代码1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; double sum = 0.0; for (int i = 1; i &lt;= n; i++) &#123; sum = sum + 1.0 / i; &#125; printf("%.4lf\n", sum); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017网易游戏雷火盘古实习生招聘笔试真题-推箱子]]></title>
      <url>%2F2017%2F03%2F17%2F2017%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E6%8E%A8%E7%AE%B1%E5%AD%90%2F</url>
      <content type="text"><![CDATA[题目 大家一定玩过“推箱子”这个经典的游戏。具体规则就是在一个N*M的地图上，有1个玩家、1个箱子、1个目的地以及若干障碍，其余是空地。玩家可以往上下左右4个方向移动，但是不能移动出地图或者移动到障碍里去。如果往这个方向移动推到了箱子，箱子也会按这个方向移动一格，当然，箱子也不能被推出地图或推到障碍里。当箱子被推到目的地以后，游戏目标达成。现在告诉你游戏开始是初始的地图布局，请你求出玩家最少需要移动多少步才能够将游戏目标达成。 输入描述 每个测试输入包含1个测试用例第一行输入两个数字N，M表示地图的大小。其中0&lt;N，M&lt;=8。接下来有N行，每行包含M个字符表示该行地图。其中 . 表示空地、X表示玩家、*表示箱子、#表示障碍、@表示目的地。每个地图必定包含1个玩家、1个箱子、1个目的地。 输出描述 输出一个数字表示玩家最少需要移动多少步才能将游戏目标达成。当无论如何达成不了的时候，输出-1。 输入例子 4 4…...*@…..X..6 6…#..…… #*##....##.#..X….@#… 输出例子 311 问题分析这题是看了网上的解答才知道是BFS问题，自己一开始用的递归没做出来下面的代码来自 http://blog.csdn.net/u010009169/article/details/60892521 [如有侵权，请联系我删除] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using std::vector;using std::queue;using std::cin;using std::cout;/*4 4......*@.....X..*/int st[10][10][10][10];int x, y, bx, by, tx, ty;int m, n;vector&lt;vector&lt;char&gt;&gt; mm;bool valid(int x, int y) &#123; //cout &lt;&lt;m&lt;&lt;" "&lt;&lt;n&lt;&lt;"-"&lt;&lt;endl; if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; mm[x][y] != '#')return true; return false;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; mm = std::vector&lt;std::vector&lt;char&gt;&gt;(m, vector&lt;char&gt;(n)); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) &#123; char t; cin &gt;&gt; t; if (t == 'X') &#123; x = i; y = j; // cout &lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl; &#125; if (t == '*') &#123; bx = i; by = j; &#125; if (t == '@') &#123; tx = i; ty = j; &#125; mm[i][j] = t; &#125;// record every state of the //左，右，下，上 vector&lt;vector&lt;int&gt;&gt; next = &#123;&#123;-1, 0&#125;,&#123;1, 0&#125;,&#123;0, 1&#125;,&#123;0, -1&#125;&#125;; queue&lt;vector&lt;int&gt;&gt; que; que.push(&#123;x, y, bx, by&#125;); st[x][y][bx][by] = 1; while (!que.empty()) &#123; vector&lt;int&gt; t = (vector&lt;int&gt; &amp;&amp;) que.front(); que.pop(); x = t[0]; y = t[1]; bx = t[2]; by = t[3]; for (int i = 0; i &lt; next.size(); i++) &#123; int nx = x + next[i][0], ny = y + next[i][1]; int nnx = nx + next[i][0], nny = ny + next[i][1]; if (valid(nx, ny) &amp;&amp; (nx != bx || ny != by) &amp;&amp; st[nx][ny][bx][by] == 0) &#123; st[nx][ny][bx][by] = st[x][y][bx][by] + 1; que.push(&#123;nx, ny, bx, by&#125;); continue; &#125; else if (nx == bx &amp;&amp; ny == by &amp;&amp; valid(nnx, nny) &amp;&amp; st[nx][ny][nnx][nny] == 0) &#123; st[nx][ny][nnx][nny] = st[x][y][bx][by] + 1; if (mm[nnx][nny] == '@') &#123; cout &lt;&lt; st[nx][ny][nnx][nny] - 1; return 0; &#125; que.push(&#123;nx, ny, nnx, nny&#125;); &#125; &#125; &#125; cout &lt;&lt; -1; return 0;&#125; 代码分析st[10][10][10][10]是一个思维数组，用来存放当前点到终点已经走过了多少步，例如1st[x][y][bx][by] = 1; 程序分为两步走： 人还没到箱子处，人走，箱子不动 人到达箱子处，人和箱子一起动 表示点 (x,y) 到点 (bx,by)之前已经走过的步数为1。用队列来存储待搜索的点。最坏的情况是搜索完全部的点后不能到达终点， 所以队列不为空时会一直进行下去。每次分四个方向走，所以是一个四层循环。第一个if条件判断的是是否到达了目的地处，第二个if条件第一次执行是到了箱子处，到达之后，人开始推着箱子前进，所有人和箱子始终是一个方向的，就有了1st[nx][ny][nnx][nny] = st[x][y][bx][by] + 1 接下来人就换着方向推箱子去找终点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017网易游戏雷火盘古实习生招聘笔试真题-最大和]]></title>
      <url>%2F2017%2F03%2F17%2F2017%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
      <content type="text"><![CDATA[题目 在一个N*N的数组中寻找所有横，竖，左上到右下，右上到左下，四种方向的直线连续D个数字的和里面最大的值 输入描述 每个测试输入包含1个测试用例，第一行包括两个整数 N 和 D :3 &lt;= N &lt;= 1001 &lt;= D &lt;= N接下来有N行，每行N个数字d:0 &lt;= d &lt;= 100 输出描述 输出一个整数，表示找到的和的最大值 输入例子 4 287 98 79 6110 27 95 7020 64 73 2971 65 15 0 输出例子 193 问题分析每个点需要计算八个方向D个数的和，可以用暴力枚举计算，这样会有很多重复计算对于每个点，我只计算，→，↓，↘，↗四个方向的值。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int getMax(int *array, int n, int d) &#123; int max_sum = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int line_heng = 0, line_shu = 0, you_shang_line = 0, you_xia_line = 0; for (int k = 0; k &lt; d; k++) &#123; if (i + d &lt;= n) &#123; line_shu += array[(i + k) * n + j]; if(j + d &lt;= n) &#123; you_xia_line += array[(i + k) * n + j + k]; &#125; &#125; if (j + d &lt;= n) &#123; line_heng += array[i * n + j + k]; if (i &gt;= d - 1) &#123; you_shang_line += array[(i - k) * n + j + k]; &#125; &#125; &#125; max_sum = max(max_sum, line_shu); max_sum = max(max_sum, line_heng); max_sum = max(max_sum, you_xia_line); max_sum = max(max_sum, you_shang_line); &#125; &#125; return max_sum;&#125;int main() &#123; int n, d, a; cin &gt;&gt; n &gt;&gt; d; int *array = new int[n * n]; for (int i = 0; i &lt; n * n; i++) &#123; cin &gt;&gt; a; array[i] = a; &#125; cout &lt;&lt; getMax(array, n, d) &lt;&lt; endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017网易游戏雷火盘古实习生招聘笔试真题-字符串编码]]></title>
      <url>%2F2017%2F03%2F17%2F2017%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E9%9B%B7%E7%81%AB%E7%9B%98%E5%8F%A4%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E7%9C%9F%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%2F</url>
      <content type="text"><![CDATA[更新看到了网友一个简洁的代码 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; int num=1; for(int i=1;i&lt;=str.length();i++)&#123; if(str[i]==str[i-1]) num++; else&#123; cout&lt;&lt;num&lt;&lt;str[i-1]; num=1; &#125; &#125; return 0;&#125; 题目:输入描述 每个测试输入包含1个测试用例每个测试用例输入只有一行字符串，字符串只包括大写英文字母，长度不超过10000。 输出描述 输出编码后的字符串 输入例子 AAAABCCDAA 输出例子 4A1B2C1D2A 问题分析仔细审题很容易就过了 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdint.h&gt;#include&lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string bianMa(string s) &#123; string out = ""; int count = 0; char curent_char = s[0]; for (int i = 0; i &lt; s.length(); i++) &#123; if (curent_char == s[i]) &#123; count++; if(i==s.length()-1)&#123; string s1 = to_string(count) + s[i]; out += s1; &#125; &#125; else &#123; string s1 = to_string(count) + s[i-1]; out += s1; count = 1; curent_char = s[i]; if (i == s.length() - 1)&#123; s1 = to_string(count) + s[i]; out += s1; &#125; &#125; &#125; return out;&#125;int main() &#123; string a = "AAAAAA"; cout &lt;&lt; bianMa(a) &lt;&lt; endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之图的最短生成树-kruskal算法]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E7%94%9F%E6%88%90%E6%A0%91-kruskal%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[基本思想 每次从所有边中选取权值最小的一条边，将首尾节点加入集合T,剩余节点集合为G 从剩余节点组成的所有边中再选择一条权值最小的边，将首尾节点加入集合T,剩余节点集合为G 重复2并且保证已选出的边不构成回路，直到G中没有节点。 和prim的区别kruskal的计算是基于边的，在边比较少的情况下会比较快，边比较多时，prim会更好。 例子为 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void MyGraph::kruskalTree() &#123; //1、将连接矩阵转换为边集合 int n,m; vector&lt;MyEdge&gt; edge_vector = transformMatrixToEdge(); //用于判断便于边是否形成环路，下标为边的起始点，值为边的结束点 int parent[this-&gt;num]; for(int i = 0;i&lt;this-&gt;num;i++)&#123; parent[i] = 0; &#125; for (int j = 0; j &lt; edge_vector.size(); ++j) &#123; n = this-&gt;Find(parent,edge_vector[j].start); m = this-&gt;Find(parent,edge_vector[j].end); if(n!=m)&#123; parent[n] = m; cout&lt;&lt;this-&gt;node_array[edge_vector[j].start].data&lt;&lt;"---&gt;"&lt;&lt;this-&gt;node_array[edge_vector[j].end].data&lt;&lt;" value: "&lt;&lt;edge_vector[j].value&lt;&lt;endl; &#125; &#125;&#125;vector&lt;MyEdge&gt; MyGraph::transformMatrixToEdge() &#123; vector&lt;MyEdge&gt; edges; for (int i = 0; i &lt; this-&gt;num; ++i) &#123; for (int j = i+1; j &lt; this-&gt;num; ++j) &#123; if(this-&gt;array[i*this-&gt;num+j]!=this-&gt;max_value) &#123; MyEdge edge = MyEdge(i,j,this-&gt;array[i*this-&gt;num+j]); edges.push_back(edge); &#125; &#125; &#125; for (int k = 0; k &lt; edges.size(); ++k) &#123; for (int i = k+1; i &lt; edges.size(); ++i) &#123; if(edges[k].value&gt;edges[i].value)&#123; MyEdge edge = MyEdge(edges[k].start,edges[k].end,edges[k].value); edges[k] = edges[i]; edges[i] = edge; &#125; &#125; &#125; return edges;&#125;int MyGraph::Find(int *parent, int f) &#123; while(parent[f]&gt;0)&#123; f = parent[f]; &#125; return f;&#125; 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之图的遍历-深度优先搜索(DFS)和广度优先搜索(BFS)]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(DFS)%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(BFS)%2F</url>
      <content type="text"><![CDATA[两种遍历图的遍历分为深度优先搜索(Depth First Search)和广度优先搜索 深度优先搜索(DFS) 顺着起始节点的一条边一直找下去，知道这条边上的节点全部被找完，然后再开始顺着另一条边寻找。 广度优先搜索(BFS) 选起始节点连接的所有边，然后将这些边的尾节点中没有访问的加入待寻找节点结合T，起始点置为已访问，接着寻找T中每一个点连接的边，并将尾节点加入T，直到T中包含所有的节点并且都已访问。 例子说明深度优先搜索结果为：A B C E F D G H广度优先搜索结果为：A B D C F G H E 可以看出深度优先搜索就是先一条路走到底，再去走另外的路广度优先搜索就是一层一层的访问 上代码深度优先搜索(DFS)123456789101112void MyGraph::depthFirstTraverse(int node_index) &#123; cout &lt;&lt; this-&gt;node_array[node_index].data &lt;&lt; " "; this-&gt;node_array[node_index].is_visited = true; for (int i = 0; i &lt; this-&gt;num; i++) &#123; if (this-&gt;array[node_index * this-&gt;num + i] != 65535) &#123; if (!this-&gt;node_array[i].is_visited) &#123; depthFirstTraverse(i); &#125; &#125; &#125;&#125; 广度优先搜索(BFS)需要使用两个结合来存储上层访问的节点和下一层待访问的节点，然后递归调用 breadthFirstTraverseIndex()123456789101112131415161718192021222324252627282930void MyGraph::breadthFirstTraverse(int node_index) &#123; cout &lt;&lt; this-&gt;node_array[node_index].data &lt;&lt; " "; //已经访问过的节点就不再访问 this-&gt;node_array[node_index].is_visited = true; vector&lt;int&gt; cur; cur.push_back(node_index); this-&gt;breadthFirstTraverseIndex(cur);&#125;void MyGraph::breadthFirstTraverseIndex(vector&lt;int&gt; previous) &#123; if (previous.size() &lt;= 0) &#123; return; &#125; vector&lt;int&gt; last; for (int i = 0; i &lt; previous.size(); i++) &#123; for (int j = 0; j &lt; this-&gt;num; j++) &#123; if (this-&gt;array[previous[i] * this-&gt;num + j] != 65535) &#123; if (!this-&gt;node_array[j].is_visited) &#123; cout &lt;&lt; this-&gt;node_array[j].data &lt;&lt; " "; //已经访问过的节点就不再访问 this-&gt;node_array[j].is_visited = true; last.push_back(j); &#125; &#125; &#125; &#125; this-&gt;breadthFirstTraverseIndex(last);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构之图的最短生成树-prim算法]]></title>
      <url>%2F2017%2F03%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E7%94%9F%E6%88%90%E6%A0%91-prim%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[基本思想 最小生成树(Minimum cost Spanning Tree)构造连通图的最小代价生成树称为最小生成树—《大话数据结构》通俗来说就是寻找权值最小的路径集合来连接图中所有的节点。 prim算法 将起始点(可以是图中的任意节点)加入集合G. 从图中寻找到G最短的路径，加入路径集合T. 并把路径的终点加入集合G. 重复步骤2，知道G中包含所有的点 or T中边数量=点的数量-1. 为了实现此算法，我们需要定义几个变量 保存剩余节点到G的最短距离的集合lowcost 1int lowcost[num] //下标为外部的点，值为到G的距离 保存lowcost中每个边连接到G中的哪一个节点的节点集合 1int adjvex[num] //下标为外部的点，值为G中的点 代码是在大话数据结构的基础上修改的–现在能从任意节点开始图的初始化为123456789for (int i = 0; i &lt; this-&gt;num; i++) &#123; for (int j = 0; j &lt; this-&gt;num; j++) &#123; if (i == j) &#123; this-&gt;array[i * num + j] = 0; &#125; else &#123; this-&gt;array[i * num + j] = 65535; &#125;; &#125; &#125; 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546void MyGraph::primTree(int node_index) &#123; int min, i, j, k, MAXVELUE = 65535; //保存最短边的起始点，下标为外部的点，值为当前生成树中的点 int adjvex[this-&gt;num]; //保存各顶点到当前最小生成树的距离(权值)，下标为外部的点，值为到当前生成树的距离 int lowcost[this-&gt;num]; //将和起始点相关的点之间的权值加入,并设置起始点为node_index处的点 for (i = 0; i &lt; this-&gt;num; i++) &#123; lowcost[i] = this-&gt;array[node_index * num + i]; adjvex[i] = node_index; &#125; //循环剩下的点 for (i = 0; i &lt; this-&gt;num; i++) &#123; if (i != node_index) &#123; min = MAXVELUE; j = 0; k = 0; /* 循环全部顶点 选择最小值*/ while (j &lt; this-&gt;num) &#123; if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min) &#123; /* 当前权值成为最小值 */ min = lowcost[j]; /* 将当前最小值的下标存入k */ k = j; &#125; j++; &#125; cout &lt;&lt; "bian: (" &lt;&lt; this-&gt;node_array[adjvex[k]].data &lt;&lt; "," &lt;&lt; this-&gt;node_array[k].data &lt;&lt; ")" &lt;&lt; endl; /* 将当前顶点的权值设置为0,表示此顶点已经加入生成树豪华套餐 */ lowcost[k] = 0; //重新计算剩余点到生成树的距离 for (j = 0; j &lt; this-&gt;num; j++) &#123; /* 如果下标为k顶点各边权值小于此前这些顶点到达生成树的最短距离 */ if (lowcost[j] != 0 &amp;&amp; this-&gt;array[k * this-&gt;num + j] &lt; lowcost[j]) &#123; /* 将较小的权值存入lowcost相应位置 */ lowcost[j] = this-&gt;array[k * this-&gt;num + j]; /* 将当前最短边的起始点置为k */ adjvex[j] = k; &#125; &#125; &#125; &#125;&#125; 运行例子中的图为 以节点B开始，最终输出为]]></content>
    </entry>

    
  
  
</search>
